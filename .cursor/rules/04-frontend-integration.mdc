---
description:
globs:
alwaysApply: false
---
# Frontend Integration

## API Communication
Frontend components should communicate with the backend API using a dedicated API client service.

### API Client Structure
```
src/lib/
├── api/
│   ├── client.ts        # Base Axios configuration
│   ├── auth.api.ts      # Authentication endpoints
│   ├── fields.api.ts    # Field management endpoints
│   ├── bookings.api.ts  # Booking management endpoints
│   ├── products.api.ts  # Product management endpoints
│   ├── feedback.api.ts  # Feedback endpoints  
│   └── opponents.api.ts # Opponent finding endpoints
```

### Example Base Client (client.ts)
```typescript
import axios from 'axios';

const API_URL = 'http://localhost:9002/api/v1';

const apiClient = axios.create({
  baseURL: API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor for adding auth token
apiClient.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('accessToken');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Response interceptor for token refresh
apiClient.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;
    
    // If error is 401 and we haven't already tried to refresh
    if (error.response.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;
      
      try {
        const refreshToken = localStorage.getItem('refreshToken');
        const response = await axios.post(`${API_URL}/auth/refresh`, {
          refreshToken,
        });
        
        const { accessToken } = response.data;
        localStorage.setItem('accessToken', accessToken);
        
        // Update the auth header
        originalRequest.headers.Authorization = `Bearer ${accessToken}`;
        return apiClient(originalRequest);
      } catch (err) {
        // Refresh token expired or invalid
        localStorage.removeItem('accessToken');
        localStorage.removeItem('refreshToken');
        window.location.href = '/login';
        return Promise.reject(err);
      }
    }
    
    return Promise.reject(error);
  }
);

export default apiClient;
```

### Example API Service (fields.api.ts)
```typescript
import apiClient from './client';

export interface Field {
  id: number;
  name: string;
  location: string;
  size: string;
  hourlyRate: number;
  status: 'available' | 'maintenance' | 'booked';
  imageUrl: string;
  createdAt: string;
  updatedAt: string;
}

export interface FieldsResponse {
  totalItems: number;
  totalPages: number;
  currentPage: number;
  fields: Field[];
}

export interface FieldFilters {
  status?: string;
  size?: string;
  page?: number;
  limit?: number;
}

const fieldsApi = {
  getAll: async (filters?: FieldFilters): Promise<FieldsResponse> => {
    const response = await apiClient.get('/fields', { params: filters });
    return response.data;
  },
  
  getById: async (id: number): Promise<Field> => {
    const response = await apiClient.get(`/fields/${id}`);
    return response.data;
  },
  
  create: async (field: Partial<Field>): Promise<Field> => {
    const response = await apiClient.post('/fields', field);
    return response.data;
  },
  
  update: async (id: number, field: Partial<Field>): Promise<Field> => {
    const response = await apiClient.put(`/fields/${id}`, field);
    return response.data;
  },
  
  delete: async (id: number): Promise<void> => {
    await apiClient.delete(`/fields/${id}`);
  }
};

export default fieldsApi;
```

## Frontend Component Integration

### Example Admin Component (src/pages/admin/FieldManagement.tsx)
This component should implement:
- Listing all fields
- Creating new fields
- Updating field details
- Deleting fields

```typescript
import { useState, useEffect } from 'react';
import fieldsApi, { Field, FieldsResponse } from '../../lib/api/fields.api';

const FieldManagement = () => {
  const [fields, setFields] = useState<Field[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  
  useEffect(() => {
    const fetchFields = async () => {
      try {
        setLoading(true);
        const response = await fieldsApi.getAll();
        setFields(response.fields);
      } catch (err) {
        setError('Failed to load fields');
        console.error(err);
      } finally {
        setLoading(false);
      }
    };
    
    fetchFields();
  }, []);
  
  const handleDelete = async (id: number) => {
    try {
      await fieldsApi.delete(id);
      setFields(fields.filter(field => field.id !== id));
    } catch (err) {
      setError('Failed to delete field');
      console.error(err);
    }
  };
  
  // Implement create and update field handlers
  
  return (
    <div>
      {/* Render UI for field management */}
    </div>
  );
};

export default FieldManagement;
```

### Example User Component (src/pages/user/BookingField.tsx)
This component should implement:
- Browsing available fields
- Selecting a field for booking
- Submitting a booking request

```typescript
import { useState, useEffect } from 'react';
import fieldsApi, { Field } from '../../lib/api/fields.api';
import bookingsApi from '../../lib/api/bookings.api';

const BookingField = () => {
  const [fields, setFields] = useState<Field[]>([]);
  const [selectedField, setSelectedField] = useState<Field | null>(null);
  const [bookingDate, setBookingDate] = useState('');
  const [startTime, setStartTime] = useState('');
  const [endTime, setEndTime] = useState('');
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  
  useEffect(() => {
    const fetchAvailableFields = async () => {
      try {
        setLoading(true);
        const response = await fieldsApi.getAll({ status: 'available' });
        setFields(response.fields);
      } catch (err) {
        setError('Failed to load available fields');
        console.error(err);
      } finally {
        setLoading(false);
      }
    };
    
    fetchAvailableFields();
  }, []);
  
  const handleBooking = async () => {
    if (!selectedField) return;
    
    try {
      await bookingsApi.create({
        fieldId: selectedField.id,
        bookingDate,
        startTime,
        endTime
      });
      
      // Handle success
    } catch (err) {
      setError('Failed to create booking');
      console.error(err);
    }
  };
  
  return (
    <div>
      {/* Render UI for booking fields */}
    </div>
  );
};

export default BookingField;
```

## Auth Integration

### Authentication Context (src/hooks/useAuth.tsx)
```typescript
import { createContext, useContext, useState, ReactNode } from "react";
import { useNavigate } from "react-router-dom";

interface AuthContextType {
  isAuthenticated: boolean;
  login: (username: string, password: string) => Promise<boolean>;
  logout: () => void;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

interface AuthProviderProps {
  children: ReactNode;
}

export const AuthProvider = ({ children }: AuthProviderProps) => {
  const [isAuthenticated, setIsAuthenticated] = useState<boolean>(
    localStorage.getItem("admin_authenticated") === "true"
  );
  const navigate = useNavigate();

  const login = async (username: string, password: string): Promise<boolean> => {
    // For now, this is a demo implementation that always returns true
    // In a production environment, this would make an API call to validate credentials
    setIsAuthenticated(true);
    localStorage.setItem("admin_authenticated", "true");
    return true;
  };

  const logout = () => {
    setIsAuthenticated(false);
    localStorage.removeItem("admin_authenticated");
    // Redirect to home page after logout
    navigate("/");
  };

  return (
    <AuthContext.Provider value={{ isAuthenticated, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
};
```

## Protected Routes
For admin protection, use a dialog-based approach instead of redirecting:

```typescript
import { useEffect, useState } from "react";
import { useAuth } from "@/hooks/useAuth";
import { LoginDialog } from "./LoginDialog";

interface ProtectedRouteProps {
  children: React.ReactNode;
}

export function ProtectedRoute({ children }: ProtectedRouteProps) {
  const { isAuthenticated } = useAuth();
  const [showLoginDialog, setShowLoginDialog] = useState(!isAuthenticated);

  useEffect(() => {
    if (!isAuthenticated) {
      setShowLoginDialog(true);
    } else {
      setShowLoginDialog(false);
    }
  }, [isAuthenticated]);

  return (
    <>
      {children}
      <LoginDialog 
        open={showLoginDialog} 
        onOpenChange={(open) => {
          // Only allow closing if authenticated
          if (!open && !isAuthenticated) {
            return;
          }
          setShowLoginDialog(open);
        }} 
      />
    </>
  );
}
```
